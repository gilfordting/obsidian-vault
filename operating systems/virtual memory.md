chapter 3 in [xv6 book](https://pdos.csail.mit.edu/6.828/2024/xv6/book-riscv-rev4.pdf)
- each process gets own private address space and memory through this
- isolate address spaces and multiplex them onto a single physical mem
- level of indirection that allows tricks
- in xv6, tricks are:
	- mapping same memory in several address spaces (trampoline page)
	- guarding kernel and user stacks with unmapped page
# paging hardware
- RISC-V instructions manipulate virtual addresses
- machine's RAM has physical addresses
- page tables are a translation mechanism
- only bottom 39 bits of 64-bit virtual address used in Sv39
- each page table is an array of $2^{27}$ page table entries
	- 27-bit address needed to create a row index, and to locate a specific entry
- each *entry*, PTE, has a 44-bit physical page number (PPN) and some flags
- so, we use the top 27 bits of the 39 bits to index
	- reserving the bottom 12 bits
	- this creates a 56-bit physical address
- logical view of page table is just an array of PTEs (full story later)
- so the OS gets control over the address translations, at the granularity of aligned chunks of 4096 bytes ($2^{12}$)
	- this is because the bottom 12 bits are unchanged
	- so we have $2^{12}$ options for those while keeping the eventual PPN fixed
- each such chunk is a *page*
- top 25 bits of virtual address not used for translation
- there is room in PTE format for physical page entry to grow by another 10 bits
- $2^{39}$ bytes is 512 GB
	- this should be enough *address space* for applications running on RISC-V computers
	- $2^{56}$ is enough *physical memory space* for lots of I/O devices, RAM chips
	- if more needed, Sv48 defined -- 48-bit virtual addresses
- RISC-V CPU translates virtual --> physical in 3 steps
- *hierarchical* page tables, three-level tree
- the root is a 4096-byte page table page -- the bottom 12 bits of virtual address
	- it has 512 PTEs, so the next 9 bits is the index in the L0
		- these are physical addresses for page-table pages in the next level, L1
	- then, each of *those* L1 pages have 512 PTEs
		- and those PTEs are physical addresses of L2 page tables
- 27 bits -- 9 for L0 page table index, 9 for L1, 9 for L2
- if any of the three required PTEs are not present, **page-fault exception**
	- kernel will handle it
- this is a memory-efficient way of recording PTEs
- in the common case, large ranges of virtual address don't have any mappings
- so then entire page directories can be ommitted
- if only a few pages are used, starting at address zero:
	- then entries 1-511 of top-level page directory are invalid. kernel doesn't have to allocate pages for those, neither mid-level nor bottom-level
	- saves 511 pages for intermediate page directories, and 511 * 512 pages for bottom-level pages
- this three-level structure in hardware is walked by the cpu in hardware
	- as part of a load or store
	- downside of 3 levels? cpu has to load three PTEs from memory
	- so to mitigate this, we also have a [[translation look-aside buffer]] (TLB)
- what's in a page table entry?
	- flag bits telling the paging hardware *how* the virtual address can be used
	- `pte_v` for if it's present; if not set, reference to page causes exception, not allowed
	- `pte_r`: can an instruction read the page?
	- `pte_w`: ^^ but for write
	- `pte_x`: can this be interpreted as instructions and executed?
	- `pte_u`: can user-mode instructions access the page?
		- otherwise, can be used only in supervisor mode
	- etc
- the kernel needs to write physical address of root page-table page into `satp` register
	- the cpu will translate all addresses generated by subsequent instructions using the page table pointed to by its `satp`
	- each cpu has its own `satp`, so different CPUs can run different processes
	- each one has its own private address space, which is described by own page table
- kernel POV: page table is just data stored in memory
	- so the code for creating and modifying these page tables is like code that works with any tree-shaped data structure
- vocab:
	- *physical memory*: storage cells in RAM
	- *physical address*: points to a byte of physical memory
	- instructions that dereference addresses (loads, stores, jumps, function calls) just use virtual addresses
	- the hardware will translate these to physical addresses
	- these are then sent to RAM hardware
	- *address space*: set of virtual addresses valid in given page table
	- each xv6 process has separate user address space
	- xv6 kernel has own address space as well
	- *user memory*: a process's user address space
	- + the physical memory that they're allowed to access (by the page table)
	- *virtual memory*: ideas, techniques associated with page tables. using them to achieve goals, like isolation
# kernel address space
