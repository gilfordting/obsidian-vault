merge
- two sorted lists -> combined sorted list
- building block of sorting algorithms
- also basis of modern mapreduce frameworks
- parallel ordered merge alg -- input data is dynamically determined
- hard to exploit locality and tiling
- principles are relevant to other computations, like set intersection and set union
- buffer management schemes
# background
- each element in array has a key
- ordering relation $R$
- stability of ordered merge
- this allows things like previous key sorts
# sequential merge algorithm
- merge until one consumed, then do the rest
# a parallelization approach
- each thread first determines range of output positions it will produce
- uses output range as input to co-rank function
- identify corresponding input ranges that will be merged to produce the output range
- then each thread independently accesses two input subarrays and one output subarray
- so then sequential merge on subarrays
- what is the co-rank function?
- let `A` and `B` be input arrays with `m` and `n` elements
- sorted according to ordering rel
- index starts at 0
- `C` is merged array, with `m+n` elements
- observation:
	- for any $k$ such that $0 \leq k < m+n$, either:
		- an $i$ such that $0 \leq i < m$ and `C[k]` receives value from `A[i]`
		- or $j$ such that $0 \leq j < n$ and `C[k]` receives value from `B[j]`
- prefix subarray of `C[0 to 3]` of `C[4]` (subarray of 4 elements preceding `C[4]`) is result of merging `A[0]-A[2]` of `A[3]` and prefix subarray `B[0]` of `B[1]`
- subarray `C[0 to k-1]` ($k$ elements) is result of merging `A[0 to i-1]` ($i$ elements) and `B[0 to k-i-1]` ($k-i$ elements)
- second case? `C` element comes from array `B`
	- something similar
- for any $k$ such that $0 \leq k < m+n$ we can find $i$ and $j$ s.t. $k=i+j$, $0 \leq i < m$, $0 \leq j < n$ and the subarray `C[0 to k-1` = `A[0 to i-1]` + `B[0 to j-1]`
- $i$ and $j$ which define prefix subarrays needed to produce prefix subarray of `C` are unique
- for element `C[k]`, index $k$ is referred to as its *ranks*
- $i$ and $j$ are co-ranks
- how do we use this to parallelize?
- divide work among threads by dividing output array into subarrays
- assign generation of one subarray to each thread
- then once assignment is done, rank of output elements to be generated by each thread is known
- thread then uses co-rank function to determine the two input arrays it needs to merge into its output subarray
- the range depends on the actual input values
# co-rank function implementation
- take rank $k$ of an element in output array `C`, and info about `A` and `B` and return co-rank value (just $i$) for element in `A`
	- $j$ is just $k-i$
- call the co-rank function to derive beginning positions of subarrays
- thread 0 generates `C[0-3]` and thread 1 generates `C[4-8]`
- each thread calls co-rank function to derive beginning positions of subarrays that will be merged
- so subarray starting at `C[4]` is generated by merging subarrays starting at `A[3]` and `B[1]`
- we look at the co-rank values for thread $t$ and $t+1$
- co-rank function is a search operation
- binary search is possible
# basic parallel merge kernel
- divide work among threads
- two calls to co-rank function to get bounds
- mem access efficiency?
	- adjacent threads in warp not accessing adj mem locations
	- no coalescing
	- also, threads need to access `A` and `B` from GMEM for co-rank
# tiled merge kernel, improved coalescing
- move data from gmem to smem in coalesced manner, then irregular accesses are in shared memory
- also captures the small amount of data reuse across co-rank and sequential merge
- 